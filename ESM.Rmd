---
title: 'Electronic Supplementary Material'
subtitle: 'distantia: an open-source toolset to quantify dissimilarity between multivariate ecological time-series'
author: "Blas M. Benito & H. John B. Birks"
output:
  pdf_document:
    fig_caption: yes
    fig_width: 9
    highlight: tango
    includes:
      in_header: header.tex
    keep_tex: yes
    latex_engine: xelatex
    number_sections: yes
    toc: yes
    toc_depth: 2
    df_print: kable
  html_notebook:
    fig_caption: yes
    highlight: haddock
    toc: yes
    toc_depth: 3
code_folding: show
citation_package: natbib
---

```{r, eval = FALSE, echo = FALSE, message = FALSE, warning = FALSE}
#INSTALLING PACKAGES
#checking if required packages are installed, and installing them if not
list.of.packages <- c("ggplot2", "reshape2", "viridis", "cowplot", "tidyr", "stringr", "geosphere", "distantia", "devtools", "qgraph", "kableExtra", "magick", "pdftools", "sf", "rnaturalearth", "rnaturalearthdata", "zoo", "foreach", "plyr", "ggrepel", "factoextra", "magrittr")
new.packages <- list.of.packages[!(list.of.packages %in% installed.packages()[,"Package"])]
if(length(new.packages) > 0){
  install.packages(new.packages, dep=TRUE)
}

library(devtools) #to install virtualPollen from github

#from Github
if(!("distantia" %in% installed.packages())){
  install_github("blasbenito/distantia", force = TRUE)
}

options(scipen = 9999)
```


```{r, message = FALSE, warning = FALSE, error = FALSE, echo = FALSE}
library(distantia)
library(ggplot2)
library(cowplot)
library(reshape2)
library(viridis)
library(cowplot)
library(tidyr)
library(plyr)
library(stringr)
library(geosphere)
library(qgraph)
library(kableExtra)
library(magick)
library(pdftools) #requires libpoppler-cpp-dev in linux
library(sf)
library(rnaturalearth)
library(rnaturalearthdata)
library(zoo)
library(foreach)
library(Publish)
library(ggrepel)
library(factoextra)
library(magrittr)
source("sensitivity_functions.R")
```


# Examples

## Comparison of pollen sequences dated to the Last Interglacial

The data uswd in this example comprises 9 publicly available (European Pollen Database, Pangaea, Neotoma) pollen sequences attributed to the Last Interglacial period (Marine Isotope Stage 5e), also called *Eemian*, with a total of 428 samples of the 22 most abundant pollen types. The data are available under the name *eemian.RData* in the *data* folder. It comprises the dataframes *eemian.sites* (see table and map below), describing some properties of the sites (coordinates, the source database, and the original number of samples and pollen types), and *eemian.pollen*, with the pollen counts for each site and sample. Table 1 shows a summary of the datasets, and Table 2 shows several samples of the different sites.

```{r, echo = FALSE}
load("data/eemian.RData")

#preparing table
eemian.sites.table <- eemian.sites[, c("site", "lat", "lon", "topo_elev", "ncol", "nrow")]
eemian.sites.table$topo_elev <- round(eemian.sites.table$topo_elev, 0)

#adding references
eemian.sites.table$references <- c("Grüger (1983)", "Niklewski (1968)", "Kühl et al. (2007)", "Müller (2000)", "Janczyk-Kopikowa (1989)", "Frenzel (1991)", "Noryśkiewicz (1978)", "Klatkowa and Winter (1990)", "Krupiński and Morawski (1993)")

#write table
kable(eemian.sites.table, digits = 2, booktabs = T, col.names = c("Site", "Lat. (º)", "Lon. (º)", "Elev. (m)", "Pollen types", "Samples", "Reference*"), caption = "Pollen sequences publickly available representing the Last Interglacial in Central Europe.", row.names = FALSE) %>% kable_styling(latex_options = c("HOLD_position", "striped"))
```

```{r, echo = FALSE}
#EXPORTING TABLE TO HTML

kable.out <- kable(eemian.sites.table, digits = 2, booktabs = T, col.names = c("Site", "Lat. (º)", "Lon. (º)", "Elev. (m)", "Pollen types", "Samples", "Reference*"), caption = "Pollen sequences representing the Last Interglacial in Central Europe.", row.names = FALSE, format = "html")
readr::write_file(kable.out, "output/Table_3.html")
```

```{r, message = FALSE, warning = FALSE, fig.width=5, fig.height=7, fig.cap = "Map of pollen sites used in this case study.", echo = FALSE}
#PLOTTING MAP

#retrieving map
europe <- ne_countries(scale = "medium", returnclass = "sf")

#sites to sf
eemian.sites.table.sf <- st_as_sf(x = eemian.sites.table, coords = c("lon", "lat"), crs = 4326)

ggplot() +
  geom_sf(data = europe) +
  geom_sf(data = eemian.sites.table.sf, shape = 21, size = 4, fill = viridis(1, begin = 0.6)) +
  coord_sf(xlim = c(0, 30), ylim = c(42, 58)) +
  xlab("Longitude") + 
  ylab("Latitude") +
  scale_color_viridis(discrete = TRUE) +
  cowplot::theme_cowplot() + 
  ggrepel::geom_label_repel(
    data = eemian.sites.table.sf,
    aes(label = site, geometry = geometry),
    stat = "sf_coordinates",
    min.segment.length = 0,
    box.padding = 0.5
  )
```


### Data preparation

First, we use *prepareSequences()* to apply a Hellinger transformation to the pollen counts, which helps to balance the relative importance of abundant and non-abundant pollen types.

```{r}
ep <- prepareSequences(
  sequences = eemian.pollen,
  grouping.column = "site",
  time.column = "depth",
  transformation = "hellinger",
  paired.samples = FALSE
)
```


### Computation of dissimilarity among sequences

Second, we use *workflowPsi()* to compute the dissimilarity between each one of the 36 combinations of sites, and *workflowNullPsi()* to compute the probability of obtaining a given psi on restricted permutations of the input sequences (null model of the given psi). The restricted permutation is applied locally, and independently by column. On each data-point, the algorithm decides randomly to either leave it as is, or switch it with the data-point above or below it. The outcome allows to assess the probability of obtaining the observed psi value by chance on the non-permutated sequences. The result of both functions is shown in *Table 2*.

```{r, cache = TRUE}
#computing psi
ep.psi <- workflowPsi(
  sequences = ep,
  diagonal = TRUE,
  grouping.column = "site",
  time.column = "depth",
  method = "euclidean",
  paired.samples = FALSE,
  ignore.blocks = TRUE
)
```

```{r, cache = TRUE, eval = FALSE}
#computing null psi values (this will take some time!)
ep.psi.null <- workflowNullPsi(
  sequences = ep,
  diagonal = TRUE,
  grouping.column = "site",
  time.column = "depth",
  method = "euclidean",
  paired.samples = FALSE,
  ignore.blocks = TRUE,
  repetitions = 999,
  parallel.execution = TRUE
)
```

```{r, echo = FALSE}
# save(ep.psi.null, file = "output/ep_psi_null.RData")
load("output/ep_psi_null.RData")
```


```{r, echo = FALSE}
#complete table
ep.psi$psi.null <- ep.psi.null$p$p
ep.temp <- ep.psi[with(ep.psi, order(psi)), ]
kable(ep.temp, row.names = FALSE, digits = 3, booktabs = T, caption = "Dissimilarity (Psi) between Central European pollen sequences dated to the Last Interglacial. Column p represents the probability of finding each given Psi by chance. ", col.names = c("A", "B", "Psi", "p"))  %>% kable_styling(latex_options = c("HOLD_position", "striped"), font_size = 8)
```

```{r, message = FALSE, warning = FALSE, fig.width=6, fig.height=4, fig.cap = "Clustering of the Eemian pollen sites based on the dissimilarity matrix.", echo = FALSE}
#to matrix
ep.psi.matrix <- as.dist(
  formatPsi(
    psi.values = ep.psi, 
    to = "matrix"
    )
  )

#clustering
ep.psi.clust <- hclust(d = ep.psi.matrix, method = "ward.D2")

#plot
factoextra::fviz_dend(
  ep.psi.clust, k = 3, # Cut in four groups
  cex = 0.5, # label size
  k_colors = viridis(3, end = 0.5),
  color_labels_by_k = TRUE, # color labels by groups
  rect = FALSE, # Add rectangle around groups
  horiz = TRUE,
  main = ""
  )
```


```{r, message = FALSE, warning = FALSE, fig.width=4, fig.height=3, fig.cap = "Similarity between pollen sites.  Colors represent latitude, and edge thickness represent similarity (1/dissimilarity).", echo = FALSE}
#weighting psi by psi.null
ep.psi.weighted <- ep.psi[, c("A", "B", "psi")]
ep.psi.weighted$psi <- 1/ep.psi$psi

#scaling between 0 and 1, 
ep.psi.weighted$psi <- with(
  ep.psi.weighted, 
  (psi - min(psi))/(max(psi)-min(psi))
  )

#psi values to matrix
ep.psi.matrix <- formatPsi(
  psi.values = ep.psi.weighted,
  to = "matrix"
)

#reordering the matrix by latitude to apply colors
sites.ordered <- eemian.sites[with(eemian.sites, order(-lat)), "site"]
ep.psi.matrix <- ep.psi.matrix[sites.ordered, sites.ordered]

#colors by latitude
latitude.colors <- viridis::viridis(
  nrow(eemian.sites), 
  alpha = 0.7, 
  direction = 1,
  end = 0.9
  )

#plotting network
plot.network <- qgraph::qgraph(
  ep.psi.matrix,
  layout = 'spring',
  vsize = 7,
  colors = latitude.colors,
  edge.color = "gray50",
  threshold = 0.1
  )

rm(latitude.colors, ep.psi.matrix, sites.ordered, ep.psi.weighted)
```

Figure 6 shows that there is a large cluster of sites that share similarity with Klentia Stara (K_S), a closely related cluster composed by Krumbach I and Jammertal, and an isolated group, Achenhang (Ach), which is highly dissimilar to the other sites, probably due to the presence of two hiatuses in the sequence (Grüger 1983).

### Relationship between dissimilarity and geographic distance between sites.

We hypothesize that pollen assemblages during the Eemian follow the main axiom of geography, and therefore, sites that are close to each other should have higher similarity than sites that are far apart from each other. To evaluate this hypothesis, we first have to compute the geographic distances between sites from their coordinates and differences in elevation. Second, we model dissimilarity as a function of distance, difference in elevation, and difference in latitude with a GLM with Gaussian errors. Model selection is based on AIC values of the model considering all variables and the models with each variable.

```{r, echo = FALSE}
#COMPUTING GEOGRAPHIC DISTANCES BETWEEN SITES

#adding distance column
ep.psi$distance <- NA
ep.psi$elev.diff <- NA
ep.psi$lat.diff <- NA

#computing distance and latitude difference
for(i in 1:nrow(ep.psi)){

  #geographic distance
  ep.psi[i ,"distance"] <- as.vector(
    geosphere::distm(
    eemian.sites[eemian.sites$site == ep.psi[i, "A"], 
                 c("lon", "lat")], 
    eemian.sites[eemian.sites$site == ep.psi[i, "B"], 
                 c("lon", "lat")], 
    fun = distHaversine)
  ) / 1000 #returns distance in km
  
  #difference in elevation
  ep.psi[i ,"elev.diff"] <- abs(eemian.sites[eemian.sites$site == ep.psi[i, "A"], "topo_elev"] - eemian.sites[eemian.sites$site == ep.psi[i, "B"], "topo_elev"])
  
    #difference in elevation
  ep.psi[i ,"lat.diff"] <- abs(
    eemian.sites[eemian.sites$site == ep.psi[i, "A"], "lat"] -
      eemian.sites[eemian.sites$site == ep.psi[i, "B"], "lat"]
    )
  
}

#adding label column
ep.psi$label <- paste(ep.psi$A, ep.psi$B, sep = " - ")

rm(i)
```


```{r, results='asis', echo = FALSE}
#FITTING GLM MODELS

#scaling the data
ep.psi.scaled <- data.frame(
  ep.psi[, c("A", "B", "psi.null", "label")], 
  as.data.frame(
    scale(
      ep.psi[, c("psi", "distance", "elev.diff", "lat.diff")]
      )
    )
  )

#complete model
psi.complete <- glm(
    psi ~ distance + elev.diff + lat.diff, 
  data = ep.psi.scaled
  )

#summary
kable(invisible(publish(psi.complete, print = FALSE)[["regressionTable"]]), caption = "Standardized coefficients of the GLM model.", booktabs = T)  %>% kable_styling(latex_options = c("HOLD_position", "striped"))
```

Elevation difference has the higher standardized residual, and its confidence interval does not overlap with zero. Below we fit one model per variable, and compare AICs of all fitted models.

```{r, echo = FALSE}
#nested models
psi.dist <- glm(psi ~ distance, data = ep.psi.scaled)
psi.elev <- glm(psi ~ elev.diff, data = ep.psi.scaled)
psi.lat <- glm(psi ~ lat.diff, data = ep.psi.scaled)

#model comparison
aic <- AIC(
  psi.complete, 
  psi.dist, 
  psi.elev, 
  psi.lat
  )
rownames(aic) <- c(
  "All variables", 
  "Distance", 
  "Elevation difference", 
  "Latitude difference"
  )
kable(aic, digits = 2, booktabs = T, caption = "AIC values of the complete model (first row) and the nested models.") %>% kable_styling(latex_options = c("HOLD_position", "striped"))
```

According to the AIC results, the model based on the elevation difference is the one better explaining psi. The plot below shows the model fit and the data.

```{r, fig.width = 5, fig.height = 3, fig.cap = "Relationship between dissimilarity and difference in elevation between pollen sites.", echo = FALSE}
plot.elevation.diff <- ggplot(data = ep.psi, aes(
    x = elev.diff, 
    y = psi, 
    fill = distance
    )
  ) +
  geom_smooth(
    method = "glm",
    se = TRUE,
    alpha = 0.2,
    col = "gray",
    method.args = list(family = "gaussian")
    ) +
  geom_point(
    size = 3.5,
    shape = 21
    ) +
  scale_fill_viridis(
    direction = 1, 
    alpha = 0.7,
    end = 0.9
    ) +
  xlab("Elevation difference between sites (m)") + 
  ylab("Dissimilarity (psi)") + 
  labs(fill = "Dist. (km)") +
  theme(legend.key.width = unit(0.5, "lines")) + 
  cowplot::theme_cowplot()
plot.elevation.diff
```

```{r, echo = FALSE}
rm(psi.complete, psi.dist, psi.elev, psi.lat, aic)
```

### Comparing two sites

```{r, echo = FALSE}
#sites to compare
A <- "Jammertal"
B <- "Achenhang"
```

The sites `r paste(A)` and `r paste(B)`, are among the sites with a more disproportionate relationship between dissimilarity (psi = `r round(ep.psi[ep.psi$A == A, "psi"], 3)`, p = `r round(ep.psi[ep.psi$A == A, "psi.null"], 3)`), distance (`r round(ep.psi[ep.psi$A == A & ep.psi$A == B, "distance"], 0)` kilometres) and elevation difference (`r round(ep.psi[ep.psi$A == A & ep.psi$A == B, "elev.diff"], 0)` m). Considering their geographical positions, why are these sites that different? The function *workflowImportance* allows the assessment of the drop in dissimilarity (in percentage of the dissimilarity when all variables are considered) when a given variable is removed from the data. Variables with a positive psi-drop contribute positively to the dissimilarity between two sequences (the compared sequences become more similar when the variable is removed). The code below shows how the function is applied to both sequences.

```{r}
#computing importance of each variable
ep.importance <- workflowImportance(
  sequences = ep[ep$site %in% c(A, B), ],
  grouping.column = "site",
  time.column = "depth",
  method = "euclidean",
  paired.samples = FALSE,
  diagonal = TRUE,
  ignore.blocks = TRUE
)
```


```{r, echo = FALSE}
#extracting the psi.drop dataframe
psi.drop <- t(
  sort(
    ep.importance[["psi.drop"]][3:ncol(ep)], 
    decreasing = TRUE
    )
  )
```

```{r, echo = FALSE}
#printing table
kable(psi.drop, col.names = "Psi drop (%)", booktabs = T, caption = paste("Drop in dissimilarity when omitting each variable for the sequences", A, "and", B, sep = " ")) %>% kable_styling(latex_options = c("HOLD_position", "striped"))
```

According to the table, the following pollen types are the ones contributing to the dissimilarity between `r paste(A)` and `r paste(B)`: `r names(psi.drop[,1][which(psi.drop[,1] > 1)])`.


```{r, echo = FALSE, fig.width=7, fig.height=4, fig.cap = "Pollen types (Abies, Carpinus, Corylus, and Picea) contributing the most to the dissimilarity between Achenhang and Jammertal. The samples of these sequences are not aligned in depth, and therefore potential shape distortions may apply when comparing them."}

#subsetting and proportion
ep.prop <- prepareSequences(
  sequences = eemian.pollen[eemian.pollen$site %in% c(A, B), ],
  grouping.column = "site",
  time.column = "depth",
  transformation = "proportion"
)

#subsetting the data by columns with high psi.rop
plot.df <- ep.prop[, c("site", "depth", rownames(psi.drop)[psi.drop[, 1] > 0.5])]

#abbreviating column names
colnames(plot.df)[3:ncol(plot.df)] <- abbreviate(names(plot.df[, 3:ncol(plot.df)]), minlength=5)

#to long format for easier plotting
plot.df.long <- tidyr::gather(plot.df, pollen.type, pollen.count, 3:ncol(plot.df))

#plot
plot.pollen <- ggplot(data = plot.df.long, aes(x = depth, y = pollen.count, color = pollen.type)) + 
  geom_line(size = 1, alpha = 0.8) +
  facet_wrap("site", ncol = 1, scales = "free_x", strip.position="right") +
  xlab("Depth (cm)") +
  ylab("Pollen (proportion)") +
  scale_color_viridis(begin = 0.1, discrete = TRUE, end = 0.9) +
  labs(color = "Taxon") +
  theme(legend.position = "right", legend.key.width = unit(0.5, "lines")) + 
  cowplot::theme_cowplot()
plot.pollen
```


```{r, error = FALSE, message = FALSE, results="asis", echo = FALSE, eval = FALSE}
#FIGURE 3

#first pdf
pdf(file = "A1.pdf", width = 5.50, height = 2.25)
plot(plot.network)
dev.off()

#second pdf
figure.2 <- plot_grid(plot.elevation.diff, 
          plot.pollen, 
          ncol = 1, 
          align = "v", 
          axis = "l", 
          rel_heights = c(0.4, 0.6)) + 
  theme(plot.margin = unit(c(0.5, 0.5, 0.5, 0.5), "lines"))
ggsave(figure.2, filename = "A2.pdf", width = 5.50, height = 5.50, units = "in")

#merging them together
A1 <- image_read_pdf(path = "A1.pdf", density = 900)
A2 <- image_read_pdf(path = "A2.pdf", density = 900)
A12 <- image_append(c(A1, A2), stack = TRUE)

#labels
A12 <- image_annotate(A12, "a", size = 240, gravity = "northwest", location = "+100-0")
A12 <- image_annotate(A12, "b", size = 240, gravity = "west", location = "+100-1500")
A12 <- image_annotate(A12, "c", size = 240, gravity = "west", location = "+100+500")

#write
image_write(A12, path = "output/Figure_2.pdf", format = "pdf", flatten = TRUE)
```



```{r, echo = FALSE}
#cleaning workspace
rm(list = ls())
```

## Functional dynamics of three populations of Fagus sylvatica

### Data

For this example we selected three sites that, according the [EU Forest database](https://figshare.com/collections/A_high-resolution_pan-European_tree_occurrence_dataset/3288407) (Mauri et al. 2017), are mono-specific stands of *Fagus sylvatica*. Two are located very close to the coast, one in Northern Spain and another in Southern Sweden, while the remaining one has a continental setting in Western Germany.

```{r, echo = FALSE}
#loading data
load("data/evi.RData")

#preparing sites table
sites$elevation <- floor(sites$elevation)
rownames(sites) <- NULL
kable(sites, digits = 3, booktabs = T, col.names = c("Site", "Longitude (º)", "Latitude (º)", "Elevation (m)"), caption = "Coordinates and elevation of three Fagus sylvatica stands in Spain, Germany, and Sweden.") %>% kable_styling(latex_options = c("HOLD_position", "striped"))
```


```{r, echo = FALSE, fig.width=5, fig.height=5, fig.cap = "Locations of three selected stands of Fagus sylvatica in Sweden, Germany, and Spain. Locations were extracted from the EU-Forest database (Mauri et al. 2017). Green polygons represent the distribution of Fagus sylvatica in Europe, according to EUFORGEN (von Wuehlisch, 2008)"}

load("data/fagus_sylvatica_map.RData")

#retrieving map
europe <- ne_countries(scale = "medium", returnclass = "sf")

#sites to sf
sites.sf <- st_as_sf(x = sites, coords = c("lon", "lat"), crs = 4326)

ggplot() +
  geom_sf(data = europe) +
  geom_sf(data = fagus.sylvatica.map, fill = "forestgreen", alpha = 0.5, color = "forestgreen") +
  geom_sf(data = sites.sf, shape = 10, size = 5, stroke = 1, color = viridis(1)) +
  coord_sf(xlim = c(-10, 20), ylim = c(35, 60)) +
  xlab("Longitude") + 
  ylab("Latitude") +
  cowplot::theme_cowplot()
```

We used the MODISTools R package (Tuck et al. 2014) to retrieve EVI (enhanced vegetation index) values for these sites between the years 2001 and 2018 captured by the MODIS platform. The data comprise two values per month, and to aggregate to months we took the maximum EVI value recorded each month. We then coupled the data with monthly temperature and rainfall data from CRU (Harris et al. 2014).

```{r, echo = FALSE, fig.width=7, fig.height=5, fig.cap = "Monthly EVI, rainfall, and temperature of three Fagus sylvatica forests in different countries."}
#combining year and month into dates
evi.climate <- within(evi.climate, date <- sprintf("%02d-%d", year, month))

#date to actual date
evi.climate$date <- as.yearmon(evi.climate$date)

#copy
evi.climate.copy <- evi.climate

#new colnames
colnames(evi.climate.copy) <- c("year", "month", "EVI", "Rainfall", "Temperature", "site", "Date")

#to long format for easier plotting
evi.climate.long <- gather(evi.climate.copy, variable, value, 3:5)

#plotting data
data.plot <- ggplot(data = evi.climate.long, aes(x = Date, y = value, group = site, color = site)) + 
  geom_line() +
  facet_wrap("variable", ncol = 1, scales = "free_y") +
  scale_color_viridis(end = 0.7, discrete = TRUE) +
  scale_x_yearmon(n = 19) +
  ylab("") +
  xlab("Date") +
  labs(color = "Site") +
  cowplot::theme_cowplot() +
    theme(legend.position = "bottom",
        axis.text.x = element_text(angle = 45, hjust = 1, size = 10),
        panel.spacing = unit(0, "lines"))
  
data.plot
```

### Comparison of complete sequences

The general objective is to understand how the dynamics of the system varies among sites. A first approach consists of comparing the three complete sequences. Below we apply a comparison by shape using the *workflowPsi()* function, and compute psi values on restricted permutations of the datasets to assess to what extent the dissimilarity between sequences can be due to chance.

```{r, cache = TRUE}
#scaling data
ec <- prepareSequences(
  sequences = evi.climate,
  grouping.column = "site",
  exclude.columns = c("year", "month", "date"),
  transformation = "scale"
)

#compute psi
ec.psi <- workflowPsi(
  sequences = ec,
  grouping.column = "site",
  exclude.columns = c("year", "month", "date"),
  method = "euclidean",
  paired.samples = FALSE,
  diagonal = TRUE,
  ignore.blocks = TRUE
)
```


```{r, eval = FALSE}
#psi on restricted permutations
ec.psi.null <- workflowNullPsi(
  sequences = ec,
  grouping.column = "site",
  exclude.columns = c("year", "month", "date"),
  method = "euclidean",
  paired.samples = FALSE,
  diagonal = TRUE,
  ignore.blocks = TRUE,
  repetitions = 999
)
```

```{r, echo = FALSE}
# save(ec.psi.null, file = "output/   ec_psi_null.RData")
load("output/ec_psi_null.RData")
```


```{r, echo = FALSE}
#computing null expectation of psi
ec.psi$null.psi <- rowMeans(
  ec.psi.null$psi[, 4:ncol(ec.psi.null$psi)]
  )

#P
ec.psi$p <- ec.psi.null$p$p

#table
kable.out <- kable(ec.psi, digits = 4, booktabs = T, col.names = c("Sites", "", "Psi", "Psi-null", "p"), caption = "Dissimilarity in temperature, rainfall, and EVI, between Fagus sylvatica populations in Spain, Germany, and Sweden. Psi represents dissimilarity, Psi NULL is the null expectation of psi, computed as the average of 999 psi values obtained from restricted permutations of the input datasets, and p represents the proportion the psi-null values that were lower than the psi obtained on the observed datasets.")  %>% kable_styling(latex_options = c("HOLD_position", "striped"))
readr::write_file(kable.out, "output/Table_4.html")
kable.out
```

According to the psi values, the sites from Germany and Sweden have the highest similarity, followed by Spain and Germany. The comparison between Spain and Sweden yielded a psi value above the null expectation (average of psi values computed on restricted permutations of the data), and therefore the results of this comparison can be considered unreliable. It is important to take in mind that the restricted permutation applied by *workflowNullPsi()* only moves randomly selected datapoints one cell up or down, independently by column, and therefore it may yield relatively high p values and low null expectations even when the signal is relatively strong. Therefore, p values and null expectations should be considered as general indicatives of the strength of the relationship, and not as a representation of statistical significance.


### Contribution of each variable to dissimilarity

Below we use the function *workflowImportance()* to assess how the variables temperature, rainfall, and EVI contribute to the dissimilarity between the dynamics of the three populations.

```{r, fig.width=7, fig.height=3, fig.cap = "Dissimilarity change when removing one predictor at a time. Psi values of the complete datasets for each pair of sites are indicated by dashed lines. An increment in psi when a given variable is removed indicates that the variable contributes to the similarity between sites."}
#importance of variables
ec.psi.importance <- workflowImportance(
  sequences = ec,
  grouping.column = "site",
  exclude.columns =  c("year", "month", "date", "site.year"),
  method = "euclidean",
  paired.samples = FALSE, 
  diagonal = TRUE,
  ignore.blocks = TRUE
)
```


```{r, echo = FALSE}
#extracting table
importance <- ec.psi.importance$psi.drop

#removing the Spain - Sweden line
# importance <- importance[-2,]

#show table
kable.out <- kable(importance, digits = 2, booktabs = T, col.names = c("Sites", "", "Temperature", "Rainfall", "EVI"), row.names = FALSE, caption = "Percentage of dissimilarity loss when removing a given variable from the data. The psi value computed on the complete datasets is taken as reference. Positive numbers indicate that the variable contributes to dissimilarity, while negative numbers indicate that the variable contributes to similarity.")  %>% kable_styling(latex_options = c("HOLD_position", "striped"))
readr::write_file(kable.out, "output/Table_5.html")
kable.out
```

The table above shows the effect on dissimilarity of removing one variable at a time from the compared datasets. EVI plays an important role in increasing the dissimilarity between the German and the Swedish sites. All variables contribute to the dissimilarity between Spain and Germany. Regarding Spain - Sweden comparison, EVI seems to be the variable contributing most to the similarity between sites, but these have been confirmed to be dissimilar beyond the null expectation, and therefore the output of the importance analysis might not be accurate.

### Comparison of dynamics year to year

How does the dissimilarity between the dynamics of each pair of sites change over the years? Were they equally dissimilar each year within the study period? If so, what variables contributed the most to the dissimilarity?

The code below groups the data by site and year, computes *psi* for each combination of these, and organizes the output to represent it graphically.

```{r}
#grouping by site and year
ec$site.year <- paste(
  ec$site, 
  ec$year, 
  sep = "-"
  )

#computation of psi
ec.psi.year <- workflowPsi(
  sequences = ec,
  grouping.column = "site.year",
  exclude.columns = c("site", "year", "month", "date"),
  method = "euclidean",
  paired.samples = FALSE,
  diagonal = TRUE,
  ignore.blocks = TRUE
)
```


```{r, echo = FALSE}

#separating year from site name
A <- data.frame(
  do.call(
    'rbind', 
    strsplit(ec.psi.year$A, split = '-', fixed=TRUE)
    ), stringsAsFactors = FALSE)
colnames(A) <- c("A.site", "A.year")

B <- data.frame(
  do.call(
    'rbind', 
    strsplit(ec.psi.year$B, split = '-', fixed=TRUE)
    ), stringsAsFactors = FALSE)
colnames(B) <- c("B.site", "B.year")

#everything together
ec.psi.year <- data.frame(A, B, psi = ec.psi.year[,3])

#coupling different sites and same years
ec.psi.year.coupled <- ec.psi.year[which(
  ec.psi.year$A.site != ec.psi.year$B.site & 
    ec.psi.year$A.year ==  ec.psi.year$B.year
  ), ]

#ordering by site
ec.psi.year.coupled <- ec.psi.year.coupled[with(
  ec.psi.year.coupled, 
  order(A.site, B.site)
  ), c("A.site", "B.site", "B.year", "psi")]

#sites together
ec.psi.year.coupled <- data.frame(
  sites = paste(
    ec.psi.year.coupled$A.site, 
    ec.psi.year.coupled$B.site, 
    sep = " - "
    ),
  year = as.numeric(ec.psi.year.coupled$B.year),
  psi = ec.psi.year.coupled$psi,
  stringsAsFactors = FALSE
  )

#sites to factor
ec.psi.year.coupled$sites <- factor(
  ec.psi.year.coupled$sites, 
  levels = c(
    "Spain - Sweden", 
    "Spain - Germany", 
    "Germany - Sweden"
    )
  )

```

```{r, echo = FALSE, fig.width=6, fig.height=4, fig.cap = "Dissimilarity between Fagus sylvatica stands by year."}
#plot
psi.year <- ggplot(data = ec.psi.year.coupled, aes(x = year, y = psi, group = sites, color = sites)) +
  geom_line() +
  geom_smooth(method = "lm", se = TRUE, alpha = 0.1, linetype = "dotted", aes(fill = sites)) +
  scale_color_viridis(discrete = TRUE, end = 0.7, direction = -1) +
  scale_fill_viridis(discrete = TRUE, end = 0.7, direction = -1) +
  ylab(expression(paste("Dissimilarity (", psi, ")", sep=""))) +
  xlab("") +
  scale_x_continuous(breaks = c(2001:2018)) +
  labs(color = "Sites") +
  guides(fill = FALSE) +
  cowplot::theme_cowplot() +
  theme(legend.position = "top",
        axis.text.x = element_text(angle = 45, hjust = 1))
  
psi.year

```

According to these results, there are several events that could have reduced the dissimilarity between sites, and specially between the Spanish and German sites. These are the [cold](https://en.wikipedia.org/wiki/2006_European_cold_wave) and [heat](https://en.wikipedia.org/wiki/2006_European_heat_wave) waves of 2006,
the [cold wave of 2012](https://earthobservatory.nasa.gov/images/77126/cold-snap-across-europe), and the [extreme drought in Spain](https://ec.europa.eu/jrc/en/science-update/exceptional-drought-south-eastern-spain) that started in 2013, the [European-wide heat wave of 2015](https://www.climate.gov/news-features/event-tracker/summer-heat-wave-arrives-europe), and the [cold wave of 2017](https://en.wikipedia.org/wiki/January_2017_European_cold_wave).

Even thought the limited amount of data available (18 years only) prevents the assessment of the statistical significance of the temporal trend of dissimilarity between sites, and in spite of the punctuated events affecting dissimilarity, there is a pattern of increasing dissimilarity between the Spanish and the other sites, and an almost neutral decrease in the dissimilarity of the German and the Swedish sites. What variables are contributing to these patterns?

```{r, fig.width=7, fig.height=5, fig.cap = "Dissimilarity when removing a given variable. Variables with positive trends are increasing their contribution to similarity over time.", echo = FALSE, message = FALSE, warning = FALSE}
#importance of variables
ec.psi.year.importance <- workflowImportance(
  sequences = ec[, !(
    colnames(ec) %in% c("site", "year", "month", "date")
    )],
  grouping.column = "site.year",
  method = "euclidean",
  paired.samples = FALSE,
  diagonal = TRUE,
  ignore.blocks = TRUE
)

#getting the psi.drop dataframe
psi.drop <- ec.psi.year.importance$psi

#removing a column and renaming the remaining ones
psi.drop[, "All variables"] <- NULL
colnames(psi.drop) <- c(
  "A", 
  "B", 
  "temperature", 
  "rainfall", 
  "evi"
  )

#separating year from site name
A <- data.frame(
  do.call(
    'rbind', 
    strsplit(
      psi.drop$A, 
      split = '-',
      fixed=TRUE
      )
    )
  )
colnames(A) <- c("A.site", "A.year")

B <- data.frame(
  do.call(
    'rbind', 
    strsplit(
      psi.drop$B, 
      split = '-', 
      fixed=TRUE
      )
    )
  )
colnames(B) <- c("B.site", "B.year")

#everything together
psi.drop <- data.frame(A, B, psi.drop[,c("temperature", "rainfall", "evi")])

#coupling different sites and same years
psi.drop.coupled <- psi.drop[
  which(
    psi.drop$A.site != psi.drop$B.site & 
      psi.drop$A.year ==  psi.drop$B.year
    ), ]

#ordering by site
psi.drop.coupled <- psi.drop.coupled[
  with(
    psi.drop.coupled, 
    order(A.site, B.site)),
  c(
    "A.site", 
    "B.site", 
    "B.year", 
    "temperature", 
    "rainfall", 
    "evi"
    )]

#sites together
psi.drop.coupled <- data.frame(
  sites = paste(
    psi.drop.coupled$A.site, 
    psi.drop.coupled$B.site, 
    sep = " - "
    ),
  year = psi.drop.coupled$B.year,
  Temperature = psi.drop.coupled$temperature,
  Rainfall = psi.drop.coupled$rainfall,
  EVI = psi.drop.coupled$evi,
  stringsAsFactors = FALSE
  )

#to long format
psi.drop.coupled.long <- tidyr::gather(
  psi.drop.coupled, 
  variable, 
  psi, 
  c("Temperature", "Rainfall", "EVI")
  )

psi.drop.coupled.long[
  psi.drop.coupled.long$sites == "Spain - Sweden", 
  "sites"
  ] <- "SP - SW"

psi.drop.coupled.long[
  psi.drop.coupled.long$sites == "Spain - Germany", 
  "sites"
  ] <- "SP - GE"

psi.drop.coupled.long[
  psi.drop.coupled.long$sites == "Germany - Sweden", 
  "sites"
  ] <- "GE - SW"

#order of factors
psi.drop.coupled.long$sites <- factor(
  psi.drop.coupled.long$sites, 
  levels = c(
    "SP - SW", 
    "SP - GE", 
    "GE - SW"
    )
  )

#plot
psi.year.variable <- ggplot(
  data = psi.drop.coupled.long, 
  aes(
    x = year, 
    y = psi, 
    group = sites, 
    color = sites
    )
  ) +
  geom_line() +
  geom_smooth(method = "lm", 
              se = TRUE, 
              alpha = 0.1, 
              size = 0.5,
              linetype = "dotted", 
              aes(fill = sites)) +
  scale_color_viridis(
    discrete = TRUE, 
    end = 0.7, 
    direction = -1
    ) +
  scale_fill_viridis(
    discrete = TRUE, 
    end = 0.7, 
    direction = -1
    ) +
  ylab(expression(
    paste("Dissimilarity (", psi, ")", 
          sep=""))
    ) +
  xlab("") +
  facet_grid(sites ~ variable, scales = "free_y") +
  scale_x_discrete(breaks = seq(2001, 2017, by = 3)) +
  labs(color = "Sites") +
  guides(fill = FALSE, color = FALSE) +
  cowplot::theme_cowplot() +
    theme(legend.position = "bottom",
        axis.text.x = element_text(angle = 45, hjust = 1),
        strip.text.y = element_text(size = 10))
psi.year.variable
```

All variables contribute to the increment in dissimilarity between the German and Swedish. In the case of Spain vs. Sweden and Germany, rainfall is the variable with the highest contribution to the increment in similarity between sites, even though the signal is weak.

These dissimilarity trends can be explained by changes in the EVI and temperature values of each month across years. Particularly, the EVI values of the Swedish populations are increasing across most months except the colder ones, while spring and summer EVI values are being lower and lower each year in the Spanish and German populations. Increased summer temperatures in these populations would likely be behind this response, but the data available per month and year are too scarce to allow a robust assessment of significance.

```{r, echo = FALSE}
#temporal trends of the different variables data

#new.name
ec.temp <- ec

#observation index
ec.temp$observation <- rep(1:216, 3)

#scaling time
ec.temp <- data.frame(site = ec.temp$site, scale(ec.temp[, c("observation", "rainfall", "temperature", "evi")]))
ec.temp$month <- ec$month
ec.temp$year <- ec$year


#TEMPORAL TRENDS PER VARIABLE AND SITE
#evi (none is significant)
evi.ge <- glm(evi ~ observation, data = ec.temp[ec.temp$site == "Germany", ])
# summary(evi.ge) #non-significant trend
evi.sp <- glm(evi ~ observation, data = ec.temp[ec.temp$site == "Spain", ])
# summary(evi.sp) #non-significant trend
evi.sw <- glm(evi ~ observation, data = ec.temp[ec.temp$site == "Sweden", ])
# summary(evi.sw) #non-significant trend

#temperature (none is significant)
temp.ge <- glm(temperature ~ observation, data = ec.temp[ec.temp$site == "Germany", ])
# summary(temp.ge) #non-significant trend
temp.sp <- glm(temperature ~ observation, data = ec.temp[ec.temp$site == "Spain", ])
# summary(temp.sp) #non-significant trend
temp.sw <- glm(temperature ~ observation, data = ec.temp[ec.temp$site == "Sweden", ])
# summary(temp.sw) #non-significant trend

#rainfall (none is significant)
rain.ge <- glm(rainfall ~ observation, data = ec.temp[ec.temp$site == "Germany", ])
# summary(rain.ge)  #non-significant trend
rain.sp <- glm(rainfall ~ observation, data = ec.temp[ec.temp$site == "Spain", ])
# summary(rain.sp)  #non-significant trend
rain.sw <- glm(rainfall ~ observation, data = ec.temp[ec.temp$site == "Sweden", ])
# summary(rain.sw)  #non-significant trend
```

```{r, echo = FALSE, fig.width=7, fig.height=4, fig.cap = "Temperature trends by month per site and year.", warning=FALSE, error = FALSE}

#TEMPORAL TRENDS PER VARIABLE, SITE, AND MONTH
ec.temp$month <- as.factor(ec.temp$month)

#temperature
ggplot(data = ec.temp, aes(x = year, y = temperature, group = month, color = month)) + 
  geom_smooth(method = "lm", alpha = 0.1) +
  facet_wrap("site") +
  scale_color_viridis(discrete = TRUE, end = 0.9) +
  cowplot::theme_cowplot() +
  ggtitle("Temperature")
```

```{r, echo = FALSE, fig.width=7, fig.height=4, fig.cap = "EVI trends by month per site and year.", warning=FALSE, error = FALSE}
#evi
ggplot(data = ec.temp, aes(x = year, y = evi, group = month, color = month)) + 
  geom_smooth(method = "lm", alpha = 0.1) +
  facet_wrap("site") +
  scale_color_viridis(discrete = TRUE, end = 0.9) +
  cowplot::theme_cowplot() +
  ggtitle("EVI")
```


```{r, echo = FALSE, fig.width=7, fig.height=4, fig.cap = "Rainfall trends by month per site and year.", warning=FALSE, error = FALSE}
#rainfall
ggplot(data = ec.temp, aes(x = year, y = rainfall, group = month, color = month)) + 
  geom_smooth(method = "lm", alpha = 0.1) +
  facet_wrap("site") +
  scale_color_viridis(discrete = TRUE, end = 0.9) +
  cowplot::theme_cowplot() +
  ggtitle("Rainfall")
```



```{r, fig.width=7, fig.height=7, echo = FALSE, warning = FALSE, error = FALSE, message = FALSE}
#Figure 3 in paper
text.size <- 12

psi.year <- psi.year + 
  theme(legend.position = "top",
        plot.margin = unit(c(0, 0, -0.5, 0),"cm"),
        axis.text.y = element_text(size = text.size),
        axis.title.y  = element_text(size = text.size + 1),
        axis.text.x = element_text(size = text.size),
        legend.text  = element_text(size = text.size - 3),
        legend.title = element_text(size = text.size - 2),
        legend.margin = unit(c(rep(-0.5, 4)),"cm"))

data.plot <- data.plot + 
  xlab("") +
  theme(plot.margin = unit(c(0, 0.2, -0.5, 0),"cm"),
        legend.position = "top",
        axis.text.y = element_text(size = text.size - 1),
        axis.text.x = element_text(size = text.size),
        strip.text = element_text(size = text.size),
        legend.text  = element_text(size = text.size),
        legend.title = element_text(size = text.size),
        legend.margin = unit(c(rep(-0.5, 4)),"cm"))

psi.year.variable <- psi.year.variable +
  theme(strip.text.x = element_text(size = text.size),
        strip.text.y = element_text(size = text.size - 3),
        axis.text.y = element_text(size = text.size - 3),
        axis.title.y  = element_text(size = text.size + 1),
        axis.text.x = element_text(size = text.size),
        plot.margin = unit(c(0.2, 0.2, 0, 0),"cm"))
  
pp <- plot_grid(psi.year, psi.year.variable, ncol = 1, align = "hv", axis = "l", rel_heights = c(0.5, 0.5), labels = c("a","b")) + theme(plot.margin = unit(c(0.2, 0.2, -0.2, 0.2),"cm"))
ggsave(pp, filename="output/Figure_3.pdf", width = 5.50, height = 5.50)
```


```{r, echo = FALSE}
#cleaning workspace
rm(list = ls())
```

# Sensitivity of the dissimilarity metrics implemented in *distantia*

The *distantia* package implements an elastic dissimilarity measure with two distance-minimization options: elastic (comparison by shape) with diagonal and non-diagonal search of the least cost path, and a lock-step (comparison by time). It also implements several distance metrics, of which Euclidean and Manhattan are the most general ones. Furthermore, depending on the nature of the data, input sequences must be transformed ("none", "scaled", "proportion", "hellinger").

In this section we explore the effect of these different options on the outcome of the dissimilarity analyses that can be carried out with the *distantia* package. The analyses will be based on two example datasets provided with the package: *climate*, and *pollenGP*. The former is a climatic dataset with 800 observations of 4 variables with different units (average temperature and rainfall, and temperatures of the warmest and coldest month) generated by a palaeoclimatic simulation (Willeit et al. 2019). The data transformations applied to this dataset will be "none" (the data with their natural values), and "scaled" (scaling and centering through the *scale()* function of the R software). The latter is a pollen dataset with 200 observations of 40 pollen types (Woillard, 1979). In this case we use the data transformations "proportion" (relative abundance of each taxa) and "hellinger" (square root of the proportions).

Two different scenarios of potential differences between the datasets and modified copies of themselves will be explored.

In **Scenario 1** we increase the differences between a dataset and its copy by modifying an increasing number of datapoints (intersection between a row and a column). This analysis involves creating a copy of a dataset, selecting a variable, selecting a case, changing its value, and comparing the original dataset with its copy through different combinations of method (elastic diagonal, elastic non-diagonal, lock-step), transformation ("none" and "scaled" for *climate*, "proportion" and "hellinger" for *pollenGP*), and distance metrics (Manhattan and Euclidean). The process is repeated a 30 times for each number of datapoints modified, and the mean and standard deviation of the resulting *psi* values are reported. 

In **Scenario 2** we remove an increasing number of randomly selected rows of the copy dataset to assess how differences in sample size impact the dissimilarity between two otherwise identical datasets through combinations of method (lock-step and elastic with and without diagonals), transformation ("none" and "scaled" for *climate*, "proportion" and "hellinger" for *pollenGP*), and distance metrics (Euclidean and Manhattan).

These operations are performed by the functions available in the file *sensitivity_functions.R* The function *repetitionsPsi()* computes psi on a given dataset and its modified copy a number of repetitions, while *sensitivityPsi()* runs each whole experiment.

The code below prepares the parameters of the experiment through the custom function *generateParams()*, which, as *repetitionsPsi()* and *sensitivityPsi()*, is not part of the *distantia* package, but can be found in the file *sensitivity_functions.R* provided as companion of the .Rmd version of this file.

```{r, eval = TRUE}
#loading functions
source("sensitivity_functions.R")

#loading the data
data("climate")
data("pollenGP")
pollen <- pollenGP[ ,1:18]
rm(pollenGP)

#removing unneeded columns
climate$sequenceId <- NULL
climate$time <- NULL
pollen$depth <- NULL
pollen$age <- NULL

#generating parameters file
#function generateParams is in sensitivity_functions.R
params.climate <- generateParams(
  data = climate, 
  transformations = c("none", "scale")
  )

params.pollen <- generateParams(
  data = pollen, 
  transformations = c("proportion", "hellinger")
  )
```


The sensitivity analysis below computes psi 30 times (repetitions) for each combination of parameters contained in the parameters dataframes. On each repetition, different data-points are modified for **Scenario 1**, and different rows are removed for **Scenario 2**. Psi values obtained from the sensitivity analysis are aggregated through repetitions, and the mean and standard deviation across repetitions are available in the output dataframe of the sensitivity analysis.

```{r, eval = FALSE}
#sensitivity for climate dataset
sensitivity.climate <- sensitivityPsi(
  data = climate, 
  params = params.climate, 
  repetitions = 30
  )

#sensitivity for pollen dataset
sensitivity.pollen <- sensitivityPsi(
  data = pollen, 
  params = params.pollen, 
  repetitions = 30
  )
```


```{r, eval = FALSE, echo = FALSE}
#saving the output
save(
  sensitivity.climate, 
  sensitivity.pollen, 
  file = "output/sensitivity_analysis.RData"
  )
```


### Scenario 1: effect of number of modified data-points

We plot changes in psi mean and standard deviation across number of data-points modified for each method and combination of transformation and distance metric.

```{r, fig.width=7, fig.height=4, fig.cap = "Psi mean and standard deviation across number of data-points modified for the climate dataset.", echo = FALSE}
load("output/sensitivity_analysis.RData")

plot.climate <- ggplot(
  data = sensitivity.climate[sensitivity.climate$remove.samples == 0, ], 
  aes(
  x = cases.to.modify, 
  y = psi.mean, 
  color = method)
  ) +
  geom_line() +
  geom_point() +
  geom_errorbar(
    aes(
      ymin=psi.mean-psi.sd, 
      ymax=psi.mean+psi.sd), 
    width=.1
    ) +
  facet_grid(transformation ~ distance) +
  labs(color = "Method", alpha = "Std. deviation.") +
  xlab("Data-points modified") + 
  ylab("Average dissimilarity (psi)") +
  theme(panel.grid.major = element_line(color = "gray50", size = 0.1)) +
  scale_color_viridis(discrete = TRUE, end = 0.9) +
  ggtitle("Climate") + 
  cowplot::theme_cowplot()
plot.climate
```


```{r, fig.width=7, fig.height=4, fig.cap = "Psi mean and standard deviation across number of data-points modified for the pollen dataset.", echo = FALSE}
plot.pollen <- ggplot(
  data = sensitivity.pollen[sensitivity.pollen$remove.samples == 0, ], 
  aes(
  x = cases.to.modify, 
  y = psi.mean, 
  color = method)
  ) +
  geom_line() +
  geom_point() +
  geom_errorbar(
    aes(
      ymin=psi.mean-psi.sd, 
      ymax=psi.mean+psi.sd), 
    width=.1
    ) +
  facet_grid(transformation ~ distance) +
  labs(color = "Method", alpha = "Std. deviation.") +
  xlab("Data-points modified") + 
  ylab("Average dissimilarity (psi)") +
  theme(panel.grid.major = element_line(color = "gray50", size = 0.1)) +
  scale_color_viridis(discrete = TRUE, end = 0.9) +
  ggtitle("Pollen") + 
  cowplot::theme_cowplot()
plot.pollen

# plot_grid(plot.climate, plot.pollen, ncol = 1)
```

We found that lock-step and elastic-diagonal methods to compute dissimilarity are practically equivalent, specially when the data are scaled and the differences between datasets are small. Both methods were, as expected, more sensitive to dissimilarity than the elastic-orthogonal method, especially when differences between the datasets were small, and the distance metric used was Euclidean. The adaptive nature of the elastic-orthogonal method also increased the standard deviation of *psi* values with larger differences between the compared datasets.

### Scenario 2: effect of difference in sample size between the compared sequences

The analysis of sensitivity of elastic measures to changes in the number of rows of one of the compared datasets shows that *psi* increases exponentially with increasing number of samples removed from the copy dataset. This finding indicates that, even when two sequences have the same overall dynamics, their dissimilarity scores can be highly inflated, particularly when one of the sequences has less than half the number of samples of the other sequence. The orthogonal method showed to be less sensitive to this effect, while transformation and distance metric seemed to be irrelevant. 

```{r, fig.width=7, fig.height=7, fig.cap = "Psi mean and standard deviation across number of removed samples for the climate dataset.", echo = FALSE}
plot.climate.lockstep <- ggplot(
  data = sensitivity.climate[
    sensitivity.climate$method != "lock-step" & 
      sensitivity.climate$cases.to.modify == 0, 
    ], 
  aes(
  x = remove.samples, 
  y = psi.mean, 
  color = method)
  ) +
  geom_line() +
  geom_point() +
  geom_errorbar(aes(ymin=psi.mean-psi.sd, ymax=psi.mean+psi.sd), width=.1) +
  facet_grid(transformation ~ distance) +
  labs(color = "Method", alpha = "Std. deviation.") +
  xlab("Number of removed samples") + 
  ylab("Average dissimilarity (psi)") +
  theme(panel.grid.major = element_line(color = "gray50", size = 0.1)) +
  scale_color_viridis(discrete = TRUE, end = 0.72) +
  ggtitle("Climate") + 
  cowplot::theme_cowplot()
```

```{r, fig.width=7, fig.height=7, fig.cap = "Psi mean and standard deviation across number of removed samples for the pollen dataset.", echo = FALSE}
plot.pollen.lockstep <- ggplot(
  data = sensitivity.pollen[
    sensitivity.pollen$method != "lock-step" & 
      sensitivity.pollen$cases.to.modify == 0, 
    ], 
  aes(
  x = remove.samples, 
  y = psi.mean, 
  color = method)
  ) +
  geom_line() +
  geom_point() +
  geom_errorbar(aes(ymin=psi.mean-psi.sd, ymax=psi.mean+psi.sd), width=.1) +
  facet_grid(transformation ~ distance) +
  labs(color = "Method", alpha = "Std. deviation.") +
  xlab("Number of removed samples") + 
  ylab("Average dissimilarity (psi)") +
  theme(panel.grid.major = element_line(color = "gray50", size = 0.1)) +
  scale_color_viridis(discrete = TRUE, end = 0.72) +
  ggtitle("Pollen") + 
  cowplot::theme_cowplot()

plot_grid(plot.climate.lockstep, plot.pollen.lockstep, ncol = 1)
```


```{r, fig.width=7, fig.height=7, echo = FALSE, results = "hide"}
#Figure 4 in Paper

#subsetting by method and transformation
sensitivity.climate.plot <- sensitivity.climate[sensitivity.climate$distance == "euclidean" & sensitivity.climate$transformation == "scale", ]
sensitivity.climate.plot$group <- "climate"

#shifting overlapping lines
sensitivity.climate.plot$psi.mean <- sensitivity.climate.plot$psi.mean + c(-0.01, 0.01, 0.02, -0.02, 0)[ as.factor(sensitivity.climate.plot$method)]

sensitivity.pollen.plot <- sensitivity.pollen[sensitivity.pollen$distance == "euclidean" & sensitivity.pollen$transformation == "hellinger", ]
sensitivity.pollen.plot$group <- "pollen"

#together
sensitivity.plot <- rbind(sensitivity.climate.plot, sensitivity.pollen.plot)

#cases to modify as percentage of the total cases
sensitivity.plot$cases.to.modify <- (sensitivity.plot$cases.to.modify * 100) / (dim(climate)[1] * dim(climate)[2])

sensitivity.plot[sensitivity.plot$group == "pollen", "remove.samples"] <- (sensitivity.plot[sensitivity.plot$group == "pollen", "remove.samples"] * 100) / nrow(pollen)
sensitivity.plot[sensitivity.plot$group == "climate", "remove.samples"] <- (sensitivity.plot[sensitivity.plot$group == "climate", "remove.samples"] * 100) / nrow(climate)


#shifting overlapping lines
sensitivity.plot$cases.to.modify <- sensitivity.plot$cases.to.modify + c(0, 1, 4, 3, 2)[ as.factor(sensitivity.pollen.plot$method)]

#abbreviate methods
# sensitivity.plot$method <- abbreviate(sensitivity.plot$method, minlength = 8)
sensitivity.plot$method <- gsub("elastic - orthogonal - no blocks", "elasor no blocks", sensitivity.plot$method)
sensitivity.plot$method <- gsub("elastic - orthogonal", "elasor", sensitivity.plot$method)
sensitivity.plot$method <- gsub("elastic - diagonal", "elasdi", sensitivity.plot$method)
sensitivity.plot$method <- gsub("elastic - diagonal	- no blocks", "elasdi no blocks", sensitivity.plot$method)

# sensitivity.plot$method <- gsub("elastic", "elas", sensitivity.plot$method)
# sensitivity.plot$method <- gsub("diagonal", "di", sensitivity.plot$method)
# sensitivity.plot$method <- gsub("orthogonal", "or", sensitivity.plot$method)
# sensitivity.plot$method <- gsub("no blocks", "nb", sensitivity.plot$method)
sensitivity.plot$method <- gsub(" - ", " ", sensitivity.plot$method)
sensitivity.plot$method <- gsub("lock-step", "locks", sensitivity.plot$method)

plot.modified.datapoints <- ggplot(
  data = sensitivity.plot[sensitivity.plot$remove.samples == 0, ], 
  aes(
  x = cases.to.modify, 
  y = psi.mean, 
  color = method)
  ) +
  geom_line() +
  geom_point() +
  geom_errorbar(aes(ymin=psi.mean-psi.sd, ymax=psi.mean+psi.sd), width=.1) +
  facet_wrap("group", scales = "free_y") +
  labs(color = "Method", alpha = "Std. deviation.") +
  xlab("Modified data-points (%)") + 
  ylab(expression(Dissimilarity ~ (psi))) +
  scale_color_viridis(discrete = TRUE, direction = 1, end = 0.9) +
  cowplot::theme_cowplot() + 
  theme(legend.position = "top",
        plot.margin = unit(c(1, 1, -2, 1), "lines"),
        legend.text = element_text(size = 10),
        legend.title = element_text(size = 10),
        legend.key.width = unit(.25,"cm"))


#removed samples
sensitivity.plot <- sensitivity.plot[
    sensitivity.plot$method != "locks" & 
      sensitivity.plot$cases.to.modify < 5, 
    ]
sensitivity.plot$method <- factor(sensitivity.plot$method)

plot.removed.samples <- ggplot(
  data = sensitivity.plot, 
  aes(
  x = remove.samples, 
  y = psi.mean, 
  color = method)
  ) +
  geom_line() +
  geom_point() +
  geom_errorbar(aes(ymin=psi.mean-psi.sd, ymax=psi.mean+psi.sd), width=.1) +
  facet_wrap("group", scales = "free_y") +
  labs(color = "Method", alpha = "Std. deviation.") +
  xlab("Removed samples (%)") + 
  ylab(expression(Dissimilarity ~ (psi))) +
  theme(panel.grid.major = element_line(color = "gray50", size = 0.1)) +
  scale_color_viridis(discrete = TRUE, end = 0.72, direction = 1) +
  scale_x_continuous(breaks = seq(0, 80, by = 20)) +
  cowplot::theme_cowplot() + 
  theme(legend.position = "none",
        plot.margin = unit(c(-2, 1, 1, 1), "lines"))

p1 <- plot_grid(plot.modified.datapoints, plot.removed.samples, ncol = 1, align = "hv", axis = "left", rel_heights = c(0.8, 1))
ggsave(p1, filename="output/Figure_4.pdf", width = 5.50, height = 5.50)
```


```{r, echo = FALSE}
#cleaning workspace
rm(list = ls())
```


```{r, fig.width=2.75, fig.height=3.2, echo = FALSE, warning = FALSE, message = FALSE, eval = FALSE}

#loading data
data(sequenceA)

#making it shorter
sequenceA <- sequenceA[1:20, 1:2]
colnames(sequenceA) <- c("v1", "v2")

#subsetting to simplify
set.seed(10)
sample.A <- sort(sample(1:20, 10))
A <- sequenceA[sample.A, ]
B <- sequenceA[-sample.A, ]

# A <- sequenceA[, 1:2]
# B <- sequenceB[, 1:2]

#preparing
  AB <- prepareSequences(
  sequence.A = A,
  sequence.A.name = "A",
  sequence.B = B,
  sequence.B.name = "B",
  merge.mode = "complete",
  if.empty.cases = "zero",
  transformation = "none"
)


#distance matrix
AB.distance.matrix <- distanceMatrix(
  sequences = AB,
  method = "manhattan"
)

#least cost matrix
AB.least.cost.matrix <- leastCostMatrix(
  distance.matrix = AB.distance.matrix
)

#least cost matrix diagonal
AB.least.cost.matrix.diagonal <- leastCostMatrix(
  distance.matrix = AB.distance.matrix,
  diagonal = TRUE
)

#getting least cost path
AB.least.cost.path <- leastCostPath(
  distance.matrix = AB.distance.matrix,
  least.cost.matrix = AB.least.cost.matrix
  )

#getting least cost diagonal
AB.least.cost.path.diagonal <- leastCostPath(
  distance.matrix = AB.distance.matrix,
  least.cost.matrix = AB.least.cost.matrix,
  diagonal = TRUE
  )

#autosum of sequences
AB.autosum <- autoSum(
  sequences = AB,
  least.cost.path = AB.least.cost.path.diagonal,
  method = "manhattan"
  )

#least cost
AB.least.cost <- leastCost(
  least.cost.path = AB.least.cost.path
  )

#compute psi
AB.psi <- psi(
  least.cost = AB.least.cost,
  autosum = AB.autosum
  )

#diagonal
diagonal <- data.frame(A = 1:10, B = 1:10)

#plot matrix in ggplot
AB.distance.matrix.long <- reshape2::melt(
  AB.distance.matrix[[1]]
  )
colnames(AB.distance.matrix.long) <- c("A", "B", "distance")

#dividing distance by 100
AB.distance.matrix.long$distance <- AB.distance.matrix.long$distance / 100

plot.matrix <- ggplot() +
  geom_tile(
    data = AB.distance.matrix.long, 
    aes(
      x = A, 
      y = B, 
      fill = distance
      )
    ) +
  scale_fill_viridis(alpha = 0.8, direction = -1, end = 0.9) +
  theme(axis.line = element_blank(),
        axis.text.x = element_blank(),
        axis.text.y = element_blank(),
        axis.ticks = element_blank(),
        axis.title.x = element_blank(),
        axis.title.y = element_blank(),
        legend.position = "top",
        plot.margin = unit(c(1.5,0,0,0), "lines"),
        panel.background=element_blank(),
        panel.border=element_blank(),
        panel.grid.major=element_blank(),
        panel.grid.minor=element_blank(),
        plot.background=element_blank(),
        legend.margin = margin(
          t = c(-1, 0, -1, 1), 
          unit = "lines")
        ) +
  geom_path(
    data = diagonal,
    aes(x = A, y = B),
    color = "gray80",
    size = 1) +
  geom_path(
    data = AB.least.cost.path[[1]], 
    aes(x = A, y = B), 
    color = "gray50", 
    size = 1) +
  geom_path(
    data = AB.least.cost.path.diagonal[[1]], 
    aes(x = A, y = B), 
    linetype = "dotted",
    color = "gray20",
    size = 0.8) +
labs(fill = "Distance")

#plot time-series
m <- 30

#add index
A_ <- data.frame(time = 1:10, A)
B_ <- data.frame(time = 1:10, B)

#to long
A.long <- tidyr::gather(A_, variable, value, 2:3)
B.long <- tidyr::gather(B_, variable, value, 2:3)

#plotting
plot.A <- ggplot(
  data = A.long, 
  aes(
    x = time, 
    y = value, 
    group = variable, 
    color = variable
    )
  ) +
  geom_path(size = 0.8, aes(alpha = 0.8))  +
  geom_point(size = 1) +
  scale_color_viridis(direction = -1, 
                      discrete = TRUE,
                      begin = 0.2,
                      end = 0.8) +
  theme(axis.text.x = element_text(size = 8),
        axis.text.y = element_blank(),
        axis.ticks.y = element_blank(),
        axis.line.y = element_blank(),
        axis.title.y = element_blank(),
        axis.title.x = element_text(size = 9),
        legend.position = "none",
        panel.background = element_blank(),
        panel.border = element_blank(),
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        plot.background = element_blank(),
        plot.margin = unit(c(-0.5,0.5,0.5,0.5), "lines"),
        axis.line.x = element_line(size = 0.1),
        axis.ticks.x = element_line(size = 0.1)) +
  scale_x_continuous(breaks = 1:10) + 
  coord_cartesian(
    ylim = c(min(A.long$value) - m, 
             max(A.long$value) + m)
    ) + xlab("Multivariate time-series B")

#plotting
plot.B <- ggplot(
  data = B.long, 
  aes(
    y = time, 
    x = value, 
    group = variable, 
    color = variable)
  ) +
  geom_path(size = 0.8, aes(alpha = 0.8))  +
  geom_point(size = 1) +
  scale_color_viridis(direction = -1, 
                      discrete = TRUE,
                      begin = 0.2,
                      end = 0.8) +
  theme(axis.text.x = element_blank(),
        axis.text.y = element_text(size = 8),
        axis.ticks.x = element_blank(),
        axis.line.x = element_blank(),
        axis.title.x = element_blank(),
        axis.title.y = element_text(size = 9),
        legend.position = "none",
        panel.background = element_blank(),
        panel.border = element_blank(),
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        plot.background = element_blank(),
        plot.margin = unit(c(3.0,-0.5,0.5,0.2), "lines"),
        axis.line.y = element_line(size = 0.1),
        axis.ticks.y = element_line(size = 0.1)) +
  scale_y_continuous(breaks = 1:10) + 
  coord_cartesian(
    xlim = c(min(B.long$value) - m, 
             max(B.long$value) + m)
    ) + ylab("Multivariate time-series A")

#multipanel plot and export to pdf
figure.1 <- plot_grid(
  plot.B, 
  plot.matrix, 
  NULL, 
  plot.A, 
  rel_widths = c(0.20, 0.8), 
  rel_heights = c(0.8, 0.20))
ggsave(figure.1, filename="output/Figure_1.pdf", width = 2.75, height = 3.2)

```


# References

Willeit, M., Ganopolski, A., Calov, R., & Brovkin, V. (2019). Mid-Pleistocene transition in glacial cycles explained by declining CO2 and regolith removal. Science Advances, 5(4), eaav7337. doi:10.1126/sciadv.aav7337

Woillard, G. M. (1978). Grande Pile peat bog: A continuous pollen record for the last 140,000 years. Quaternary Research, 9(1), 1–21. doi:10.1016/0033-5894(78)90079-0

Mauri, A., Strona, G., & San-Miguel-Ayanz, J. (2017). EU-Forest, a high-resolution tree occurrence dataset for Europe. Scientific Data, 4, 160123. doi:10.1038/sdata.2016.123

Tuck et al. (2014). MODISTools - downloading and processing MODIS remotely sensed data in R Ecology & Evolution, 4(24), 4658 - 4668.

Harris, I., Jones, P. D., Osborn, T. J., & Lister, D. H. (2014). Updated high-resolution grids of monthly climatic observations – the CRU TS3.10 Dataset. International Journal of Climatology, 34(3), 623–642. doi:10.1002/joc.3711

von Wuehlisch, G. (2008). EUFORGEN Technical guidelines for genetic conservation and use for European beech. Biodiversity International. Rome, Italy. URL: http://www.euforgen.org/species/fagus-sylvatica/

Grüger E (1983) Untersuchungen zur Gliederung und Vegetationsgeschichte des Mittelpleistozäns am Samerberg in Oberbayern. Geologica Bavarica 84:21-40

Niklewski J (1968) Interglacial eemski w; Glowczynie kolo Wyszogrodu [The Eemian interglacial at Glowczyn near Wyszgrod, central Poland]. Monographiae Botanicae 27:125-191

Kühl N, Litt T, Schölzel C, Hense A (2007) Eemian and Early Weichselian temperature and precipitation variability in northern Germany. Quaternary Science Reviews 26:3311-3317

Müller UC (2000) A Late-Pleistocene pollen sequence from the Jammertal, south-western Germany with particular reference to location and altitude as factors determining Eemian forest composition. Vegetation History and Archaeobotany 9 (2):125-131. doi:10.1007/bf01300062

Janczyk-Kopikowa Z (1989) A new locality of Eemian interglacial deposits near Deblin. Kwartalnik Geologiczny 33 (2):269-275

Frenzel B (1991) Über einen frühen letzteiszeitlichen Vorstoss des Rheingletschers in das deutsche Alpenvorland. Paläoklimaforschung 1:377-400

Noryśkiewicz B (1978) Interglacjał Eemski w Nakle nad Notecią [The Eemian Interglacial at Nakło on the River Noteć (N Poland)]. Acta Palaeobotanica 19 (1):67-112

Klatkowa H, Winter H (1990) The Eemian Interglacial at Ostrow near Grabica. Acta Geographica Lodziensia 61:59-68

Krupiński KM, Morawski W (1993) Geological position and pollen analysis of Eemian interglacial sediments of Warsaw-Wawrzyszew. Acta Palaeobotanica 33 (1):309-346
